//! Test fixtures for running client RPC tests from external crates
//!
//! For validator/indexer development, the struct must be added to this crate (validator.rs / indexer.rs)
//! and the test fixtures must be expanded to include the additional process
//!
//! If running test fixtures from an external crate, the chain cache should be generated by running a
//! `generate_chain_cache` function: `generate_zcashd_chain_cache()` or `generate_zebrad_large_chain_cache()`
//! which will cache the chain in a `CARGO_MANIFEST_DIR/chain_cache/client_rpcs` directory
//!
//! ```ignore(incomplete)
//! #[ignore = "not a test. generates chain cache for client_rpc tests."]
//! #[tokio::test]
//! async fn generate_zcashd_chain_cache() {
//!   zcash_local_net::test_fixtures::generate_zcashd_chain_cache(
//!     None,
//!     None,
//!     None,
//!   )
//!   .await;
//! }
//! ```

// use testvectors::REG_O_ADDR_FROM_ABANDONART;

use zcash_local_net::{
    indexer::lightwalletd::Lightwalletd,
    process::Process,
    utils,
    validator::{zebrad::Zebrad, Validator as _},
    LocalNet,
};
/// Generates zebrad chain cache for client RPC test fixtures requiring a large chain
pub async fn generate_zebrad_large_chain_cache() {
    let mut local_net = LocalNet::<Zebrad, Lightwalletd>::launch_default()
        .await
        .unwrap();

    local_net.validator().generate_blocks(150).await.unwrap();

    let chain_cache_dir = utils::chain_cache_dir();
    if !chain_cache_dir.exists() {
        std::fs::create_dir_all(chain_cache_dir.clone()).unwrap();
    }
    local_net
        .validator_mut()
        .cache_chain(chain_cache_dir.join("client_rpc_tests_large"));
}

// FIXME: could've not been ignored, but relies on zingolib.
/// Generates zcashd chain cache for client RPC test fixtures
#[ignore = "FIXME: could've not been ignored, but relies on zingolib"]
pub async fn generate_zcashd_chain_cache() {
    // let mut local_net = LocalNet::<Lightwalletd, Zcashd>::launch(
    //     LightwalletdConfig {
    //         lightwalletd_bin,
    //         listen_port: None,
    //         zcashd_conf: PathBuf::new(),
    //         darkside: false,
    //     },
    //     ZcashdConfig {
    //         zcashd_bin,
    //         zcash_cli_bin,
    //         rpc_listen_port: None,
    //         activation_heights: default_regtest_heights(),
    //         miner_address: Some(REG_O_ADDR_FROM_ABANDONART),
    //         chain_cache: None,
    //     },
    // )
    // .await;

    // local_net.validator().generate_blocks(2).await.unwrap();

    // let lightclient_dir = tempfile::tempdir().unwrap();
    // FIXME
    // let (mut faucet, mut recipient) = client::build_lightclients(
    //     lightclient_dir.path().to_path_buf(),
    //     local_net.indexer().port(),
    // );

    // TODO: use second recipient taddr
    // recipient.do_new_address("ozt").await.unwrap();
    // let recipient_addresses = recipient.do_addresses().await;
    // recipient taddr child index 0:
    // tmFLszfkjgim4zoUMAXpuohnFBAKy99rr2i
    //
    // recipient taddr child index 1:
    // tmAtLC3JkTDrXyn5okUbb6qcMGE4Xq4UdhD
    //
    // faucet taddr child index 0:
    // tmBsTi2xWTjUdEXnuTceL7fecEQKeWaPDJd

    // FIXME
    // faucet.sync_and_await().await.unwrap();
    // from_inputs::quick_send(
    //     &mut faucet,
    //     vec![(
    //         &get_base_address(&recipient, PoolType::Shielded(ShieldedProtocol::Orchard)).await,
    //         100_000,
    //         Some("orchard test memo"),
    //     )],
    // )
    // .await
    // .unwrap();
    // from_inputs::quick_send(
    //     &mut faucet,
    //     vec![(
    //         &get_base_address(&recipient, PoolType::Shielded(ShieldedProtocol::Sapling)).await,
    //         100_000,
    //         Some("sapling test memo"),
    //     )],
    // )
    // .await
    // .unwrap();
    // from_inputs::quick_send(
    //     &mut faucet,
    //     vec![(
    //         &get_base_address(&recipient, PoolType::Transparent).await,
    //         100_000,
    //         None,
    //     )],
    // )
    // .await
    // .unwrap();
    // local_net.validator().generate_blocks(1).await.unwrap();

    // FIXME
    // recipient.sync_and_await().await.unwrap();
    // recipient.quick_shield().await.unwrap();
    // local_net.validator().generate_blocks(1).await.unwrap();

    // FIXME
    // faucet.sync_and_await().await.unwrap();
    // from_inputs::quick_send(
    //     &mut faucet,
    //     vec![(
    //         &get_base_address(&recipient, PoolType::Transparent).await,
    //         200_000,
    //         None,
    //     )],
    // )
    // .await
    // .unwrap();
    // local_net.validator().generate_blocks(1).await.unwrap();

    // FIXME
    // recipient.sync_and_await().await.unwrap();
    // from_inputs::quick_send(
    //     &mut recipient,
    //     vec![(
    //         &get_base_address(&faucet, PoolType::Transparent).await,
    //         10_000,
    //         None,
    //     )],
    // )
    // .await
    // .unwrap();
    // local_net.validator().generate_blocks(1).await.unwrap();

    // FIXME
    // recipient.sync_and_await().await.unwrap();
    // let recipient_ua = get_base_address(&recipient, PoolType::ORCHARD).await;
    // from_inputs::quick_send(
    //     &mut recipient,
    //     vec![(&recipient_ua, 10_000, Some("orchard test memo"))],
    // )
    // .await
    // .unwrap();
    // local_net.validator().generate_blocks(2).await.unwrap();

    // FIXME
    // faucet.sync_and_await().await.unwrap();
    // from_inputs::quick_send(
    //     &mut faucet,
    //     vec![(
    //         &get_base_address(&recipient, PoolType::Shielded(ShieldedProtocol::Sapling)).await,
    //         100_000,
    //         None,
    //     )],
    // )
    // .await
    // .unwrap();
    // local_net.validator().generate_blocks(1).await.unwrap();

    let chain_cache_dir = utils::chain_cache_dir();
    if !chain_cache_dir.exists() {
        std::fs::create_dir_all(chain_cache_dir.clone()).unwrap();
    }
}
